# HTTP 缓存

通过重用以前获取的资源, web 站点和应用程序的性能可以显著提高, Web 缓存减少了延迟和网络流量, 从而减少了显示资源表示所需的时间, 通过使用 HTTP 缓存, Web 站点的响应速度会更快

## 不同类型的缓存

缓存是一种存储给定资源的副本并在请求时返回的技术, 当一个网络缓存在它的存储中有一个被请求的资源时, 它拦截这个请求并返回它的副本, 而不是从原始服务器重新下载, 这实现了几个目标: 它减轻了服务器的负载, 而不需要自己服务所有的客户端, 并且通过更接近客户端来提高性能, 也就是说, 它花费更少的时间来传输资源, 对于一个网站来说, 它是实现高性能的主要组成部分, 另一方面, 它必须被正确配置, 因为并非所有资源都永远相同: 重要的是只缓存资源直到它更改, 而不是更长时间

有几种类型的缓存: 可以分为两大类: 私有缓存或共享缓存, 共享缓存是存储响应以供多个用户重用的缓存, 私有缓存是专用于单个用户的, 本页面主要讨论浏览器和代理缓存, 但也有网关缓存, CDN, 反向代理缓存和负载均衡器部署在 web 服务器上, 以更好的可靠性, 性能和扩展性的网站和 web 应用程序

![6](https://development-guides-1258936571.cos.ap-chengdu.myqcloud.com/web/guides/http/6.png)

### 私有浏览器缓存

私有缓存是专用于单个用户的, 可能已经在浏览器的设置中看到过"缓存", 浏览器缓存保存用户通过 HTTP 下载的所有文档, 该缓存用于使访问的文档可用于向后/向前导航, 保存, 作为源查看等, 而不需要额外的服务器访问, 它同样改善了缓存内容的离线浏览

### 共享代理缓存

共享缓存是存储可被多个用户重用的响应的缓存, 例如, ISP 或您的公司可能已经设置了一个 web 代理作为其本地网络基础设施的一部分, 以服务于许多用户, 这样流行的资源可以多次重用, 减少网络流量和延迟

## 缓存操作的目标

HTTP 缓存是可选的, 但通常是可取的, HTTP 缓存通常仅限于缓存对 GET 的响应, 他们可能会拒绝其他方法, 主缓存键由请求方法和目标 URI 组成(通常只使用 URI, 这是因为只有 GET 请求是缓存目标)

缓存条目的常见形式有

- 检索请求的成功结果: 对包含资源(如 HTML 文档, 图像或文件)的 GET 请求的 200 ( OK )响应

- 永久重定向: 301 ( Moved Permanently )响应

- 错误响应: 404 ( Not Found )结果页面

- 不完整的结果: 206 ( Partial Content )响应

- 如果定义了适合用作缓存键的东西, 则响应不是 GET

如果请求是内容协商的目标, 缓存条目也可能由多个存储的响应组成, 这些响应由一个辅助键区分, 有关更多细节, 请参阅下面 [Vary](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Vary) 头的信息

## 控制缓存

### Cache-Control 头

Cache-Control HTTP/1.1 通用报头字段用于在请求和响应中指定缓存机制的指令, 使用此头可以使用它提供的各种指令定义缓存策略

*无缓存*

缓存不应该存储任何关于客户端请求或服务器响应的信息, 每次都向服务器发送一个请求, 并下载完整的响应

```
Cache-Control: no-store
```

*缓存但是重新验证*

缓存将在释放缓存副本之前将请求发送到源服务器进行验证

```
Cache-Control: no-cache
```

*私有和公共缓存*

"public" 指令表示响应可以被任何缓存缓存, 如果带有 HTTP 身份验证的页面或响应状态代码通常不能缓存, 那么现在应该进行缓存, 这就非常有用

另一方面, "private" 表示响应仅供单个用户使用, 不能由共享缓存存储, 在这种情况下, 私有浏览器缓存可能会存储响应

```
Cache-Control: private
Cache-Control: public
```

*到期*

这里最重要的指令是 `max-age=<seconds>`, 这是资源被认为是新鲜的最大时间, 该指令相对于请求的时间, 并且覆盖 [Expires](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires) 头(如果设置了), 对于应用程序中不会更改的文件, 通常可以使用主动缓存, 这包括静态文件, 例如图像, CSS 文件和 JavaScript 文件

有关更多细节, 请参见下面的新鲜度部分

```
Cache-Control: max-age=31536000
```

*验证*

当使用 "must-revalidate" 指令时, 缓存必须在使用资源之前验证过期资源的状态, 过期资源不应该被使用, 有关更多细节, 请参见下面的验证部分

```
Cache-Control: must-revalidate
```

### Pragma 头

[Pragma](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Pragma) 是一个 HTTP/1.0 报头, Pragma: no-cache 类似于 Cache-Control: no-cache, 因为它强制缓存在释放缓存副本之前, 将请求提交到源服务器进行验证, 但是, 没有为 HTTP 响应指定 Pragma, 因此不能可靠地替代一般的 HTTP/1.1 Cache-Control 报头

Pragma 应该只用于向后兼容 HTTP/1.0 缓存, 此时 Cache-Control HTTP/1.1 头还没有出现

## 新鲜度

一旦资源被存储在缓存中, 理论上它可以永远由缓存提供服务, 缓存具有有限的存储空间, 因此项目会定期从存储空间中删除, 这个过程称为缓存回收, 另一方面, 服务器上的一些资源可能会发生变化, 因此应该更新缓存, 由于 HTTP 是一种客户端-服务器协议, 当资源发生变化时, 服务器无法联系缓存和客户端, 它们必须通信资源的过期时间, 在此过期时间之前, 资源是新鲜的, 过期时间过后, 资源将失效, 回收算法通常赋予新鲜资源相对于陈旧资源的特权, 注意, 过时的资源不会被驱逐或忽略, 当缓存接收到对过期资源的请求时, 它将使用 [If-None-Match](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match) 来转发该请求, 以检查该请求实际上是否仍然新鲜, 如果是, 服务器返回一个 304 ( Not Modified )头, 而不发送请求资源的主体, 从而节省一些带宽

下面是一个使用共享缓存代理的示例

![7](https://development-guides-1258936571.cos.ap-chengdu.myqcloud.com/web/guides/http/7.png)

新鲜度生存期是基于几个头计算的, 如果指定了 "Cache-Control: max-age=N" 头, 则新鲜度生命期等于 N, 如果该报头不存在(通常是这种情况), 则检查是否存在 Expires 报头, 如果 Expires 头存在, 那么它的值减去 [Date](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Date) 头的值就决定了新鲜度的生存期

### 启发式新鲜度检查

如果源服务器没有明确指定新鲜度(例如使用 Cache-Control 或 Expires 报头), 那么可以使用启发式方法

在本例中, 查找 [Last-Modified](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified) 报头, 如果存在此头, 则缓存的新鲜度生命期等于 Date 头的值减去 Last-modified 头的值除以 10, 过期时间的计算方法如下

```
expirationTime = responseTime + freshnessLifetime - currentAge
```

其中 responseTime 是根据浏览器接收响应的时间, 更多信息请参见 [RFC 7234: Hypertext Transfer Protocol (HTTP/1.1): 4.2.2, 计算启发式新鲜](https://datatracker.ietf.org/doc/html/rfc7234#section-4.2.2)

### 加速资源

我们使用缓存资源越多, Web 站点的响应性和性能就会越好, 为了优化这一点, 良好实践建议将过期时间设置在尽可能远的将来, 对于定期更新或经常更新的资源, 这是可能的, 但对于很少或不经常更新的资源, 这是有问题的, 它们是从缓存资源中获益最多的资源, 但这使得它们很难更新, 这是每个 Web 页面所包含和链接的典型技术资源: JavaScript 和 CSS 文件很少更改, 但当它们更改时, 您希望它们得到快速更新

网络开发人员发明了一种技术, Steve Souders 称之为 [revving](https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/), 不经常更新的文件以特定的方式命名: 在它们的 URL 中, 通常在文件名中, 添加一个修订(或版本)号, 这样, 该资源的每个新修订都被认为是一个永远不会更改的资源, 并且可以在很远的将来过期, 通常是一年甚至更长时间, 为了获得新版本, 必须更改到它们的所有链接, 这就是这种方法的缺点: Web 开发人员使用的工具链通常会处理额外的复杂性, 当非常可变资源发生变化时, 它们会引起对常可变资源的额外变化, 当这些文件被读取时, 其他文件的新版本也被读取

这种技术还有一个额外的好处: 同时更新两个缓存资源不会导致将一个资源的过期版本与另一个资源的新版本结合使用, 当网站有相互依赖的 CSS 样式表或 JS 脚本时, 这是非常重要的, 也就是说, 它们相互依赖, 因为它们引用相同的 HTML 元素

![8](https://development-guides-1258936571.cos.ap-chengdu.myqcloud.com/web/guides/http/8.png)

添加到 revved 资源中的修订版本不需要是像 1.1.3 这样的经典修订字符串, 或者甚至是单调增长的一组数字, 它可以是任何可以防止冲突的东西, 比如散列或日期

## 缓存验证

当到达缓存资源的过期时间时, 将对资源进行验证或再次获取, 只有当服务器提供了强验证器或弱验证器时, 才能进行验证

当用户按下 Reload 按钮时, 将触发重新验证, 如果缓存的响应包含 "Cache-Control: must-revalidate" 头, 则在正常浏览过程中也会触发, 还可以在 Advanced-> Cache 首选项面板中使用缓存验证首选项, 该面板提供了在每次加载资源时强制进行验证的选项

### ETags

[ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) 响应头是一个对用户代理不透明的值, 可以用作强验证器, 这意味着 HTTP 用户代理, 比如浏览器, 不知道这个字符串表示什么, 也不能预测它的值是什么, 如果 ETag 头是资源响应的一部分, 客户端可以在以后的请求的头中发出 [If-None-Match](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match) 来验证缓存的资源

### Last-Modified

Last-Modified 响应头可以用作弱验证器, 它被认为是弱的, 因为它只有 1 秒的分辨率, 如果响应中出现了 Last-Modified 头, 那么客户端可以发出一个 [If-Modified-Since](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since) 请求头来验证缓存的文档

当发出验证请求时, 服务器可以忽略验证请求并以正常的 200 OK 响应, 或者返回 304 Not Modified (带有一个空主体)以指示浏览器使用其缓存副本, 稍后响应还可以包含更新缓存资源的过期时间的头

## Varing responses

[Vary](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Vary) HTTP 响应头决定如何匹配未来的请求头, 以决定是使用缓存的响应, 还是必须从源服务器请求新的响应

当缓存接收到具有 Vary 头字段的请求时, 默认情况下它不能使用缓存的响应, 除非 Vary 头中指定的所有头字段都与原始(缓存的)请求和新请求匹配

![9](https://development-guides-1258936571.cos.ap-chengdu.myqcloud.com/web/guides/http/9.png)

此特性通常用于允许以未压缩和(各种)压缩形式缓存资源, 并根据用户代理支持的编码适当地为其提供服务, 例如, 服务器可以设置 Vary: Accept-Encoding, 以确保为指定支持特定编码集的所有请求缓存资源的单独版本, 例如 Accept-Encoding: gzip,deflate,sdch

```
Vary: Accept-Encoding
```

> 请谨慎 vary, 它很容易降低缓存的有效性, 缓存服务器应该使用[规范化](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#normalization)来减少重复的缓存条目和对源服务器的不必要请求, 当使用 Vary 和头和头值(可以有多个值)时, 尤其如此

Vary 头也可以用于为桌面和移动用户提供不同的内容, 或者允许搜索引擎发现页面的移动版本(也可能告诉他们没有 [Cloaking](https://en.wikipedia.org/wiki/Cloaking) 的意图), 这通常是通过 Vary: User-Agent 头来实现的, 之所以有效是因为 User-Agent 头的值对于移动和桌面客户端是不同的

```
Vary: User-Agent
```

### 规范化

如上所述, 缓存服务器将在默认情况下只匹配具有完全相同的头和头值的请求, 这意味着将向原发出请求, 并为不同用户代理指定的每一个微小变体创建一个新的缓存

例如, 默认情况下, 以下所有操作都会导致对源的单独请求和单独的缓存项: **Accept-Encoding: gzip,deflate,sdch, Accept-Encoding: gzip,deflate, Accept-Encoding: gzip**, 这是真的, 即使原始服务器可能响应, 并存储, 所有请求的相同资源(一个 gzip )

为了避免不必要的请求和重复的缓存条目, 缓存服务器应该使用规范化对请求进行预处理, 只缓存需要的文件, 例如, 在 Accept-Encoding 的情况下, 可以在执行进一步处理之前检查头中的 gzip 和其他压缩类型, 否则取消设置头, 在"伪代码"中, 如下所示

```c-like
// Normalize Accept-Encoding
if (req.http.Accept-Encoding) {
  if (req.http.Accept-Encoding ~ "gzip") {
    set req.http.Accept-Encoding = "gzip";
  }
  // elsif other encoding types to check
  else {
    unset req.http.Accept-Encoding;
  }
}
```

User-Agent 比 Accept-Encoding 有更多的变化, 因此, 如果使用 Vary: User-Agent 来缓存移动/桌面文件的变体, 同样会在请求的 User-Agent 头中检查 "mobile" 和 "desktop" 的存在, 然后清除它
